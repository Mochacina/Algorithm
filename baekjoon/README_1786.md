# KMP 알고리즘을 이용한 문자열 매칭

## 1. KMP 알고리즘이란?

KMP 알고리즘은 텍스트(Text) 문자열 안에서 특정 패턴(Pattern) 문자열을 찾는 문자열 매칭 알고리즘 중 하나입니다. 이 알고리즘은 Knuth, Morris, Pratt 세 사람에 의해 고안되었으며, 이름 또한 그들의 앞 글자를 따서 만들어졌습니다.

단순한 문자열 비교가 O(NM)의 시간 복잡도를 갖는 반면, KMP 알고리즘은 **O(N+M)** 이라는 획기적으로 빠른 시간 복잡도를 가집니다. (N: 텍스트 길이, M: 패턴 길이)

이러한 성능 향상의 핵심은 **'불일치가 발생했을 때, 이전에 일치했던 정보를 활용하여 비교 위치를 효율적으로 이동시키는 것'**에 있습니다.

## 2. 핵심 원리: 실패 함수 (Pi 배열)

KMP 알고리즘은 '실패 함수' 또는 'Pi 배열'이라고 불리는 전처리 배열을 사용합니다. `pi[i]`의 값은 **패턴의 0번 인덱스부터 i번 인덱스까지의 부분 문자열에서, 접두사(prefix)와 접미사(suffix)가 일치하는 가장 긴 길이**를 의미합니다.

예를 들어, 패턴 `P = "ABCDABD"`의 Pi 배열을 구해봅시다.

- `P[0]` "A": `pi[0] = 0`
- `P[0:1]` "AB": 접두사 "A", 접미사 "B". 일치 없음. `pi[1] = 0`
- `P[0:2]` "ABC": 접두사 "A", "AB", 접미사 "C", "BC". 일치 없음. `pi[2] = 0`
- `P[0:3]` "ABCD": 일치 없음. `pi[3] = 0`
- `P[0:4]` "ABCDA": 접두사 "**A**", 접미사 "**A**". 길이가 1인 "A"가 일치. `pi[4] = 1`
- `P[0:5]` "ABCDAB": 접두사 "**AB**", 접미사 "**AB**". 길이가 2인 "AB"가 일치. `pi[5] = 2`
- `P[0:6]` "ABCDABD": 일치 없음. `pi[6] = 0`

따라서, `P = "ABCDABD"`의 Pi 배열은 `[0, 0, 0, 0, 1, 2, 0]`이 됩니다.

### 매칭 과정에서의 활용

텍스트 `T`와 패턴 `P`를 비교하다가 `T[i]`와 `P[j]`에서 불일치가 발생했다고 가정해봅시다.

```
T: ... A B C D A B [C] ...
P:     A B C D A B [D]
                   ^ j=6, 불일치 발생
```

이때, 우리는 `P`의 `j-1` 인덱스까지는 `T`와 일치했다는 사실을 알고 있습니다. 즉, `T[i-j+1 ... i-1]`은 `P[0 ... j-1]`("ABCDAB")과 같습니다.

여기서 `pi[j-1]` 값, 즉 `pi[5]=2`를 확인합니다. 이 값은 `P[0...5]`의 접두사와 접미사가 일치하는 최대 길이가 2("AB")임을 의미합니다.

- `P[0...5]`의 접두사: `P[0...1]` = "AB"
- `P[0...5]`의 접미사: `P[4...5]` = "AB"

이는 곧, 불일치 직전까지 일치했던 텍스트 부분 문자열("ABCDAB")의 접미사 또한 "AB"라는 것을 의미합니다. 따라서 우리는 패턴을 `pi[j-1]`만큼 이동시켜, 이미 일치함이 보장된 "AB" 부분을 건너뛰고 다음 문자부터 비교를 재개할 수 있습니다.

```
T: ... A B C D A B [C] ...
               ^ 비교 재개 위치
P:         A B C D A B D
           ^ j = pi[j-1] = 2
```

이처럼 KMP 알고리즘은 불필요한 비교를 생략하고 효율적으로 탐색을 진행합니다.

## 3. 코드 설명 ([`baekjoon/bj1786.py`](baekjoon/bj1786.py:1))

### `get_pi(pattern)` 함수

```python
def get_pi(pattern):
    m = len(pattern)
    pi = [0] * m
    j = 0  # 일치하는 접두사의 길이
    for i in range(1, m):
        # 현재 j 위치의 문자와 i 위치의 문자가 다르면, j를 이전 pi 값으로 되돌림
        while j > 0 and pattern[i] != pattern[j]:
            j = pi[j - 1]
        # 문자가 일치하면 j를 1 증가시키고 pi[i]에 저장
        if pattern[i] == pattern[j]:
            j += 1
            pi[i] = j
    return pi
```

- 이 함수는 패턴 문자열 `pattern`을 입력받아 Pi 배열을 계산하여 반환합니다.
- `j`는 현재까지 일치한 접두사와 접미사의 길이를 나타냅니다.
- `i`를 1부터 `m-1`까지 순회하면서 `pi` 배열을 채워나갑니다.
- `pattern[i]`와 `pattern[j]`가 일치하지 않으면, `j`를 `pi[j-1]` 값으로 갱신하며 일치하는 부분을 찾을 때까지 거슬러 올라갑니다. 이는 다음으로 비교할 위치를 찾는 과정입니다.
- `pattern[i]`와 `pattern[j]`가 일치하면, `j`를 1 증가시켜 `pi[i]`에 저장합니다.

### `kmp(text, pattern)` 함수

```python
def kmp(text, pattern):
    pi = get_pi(pattern)
    n = len(text)
    m = len(pattern)
    matched_positions = []
    j = 0  # 패턴에서 일치한 문자의 수
    for i in range(n):
        # 텍스트와 패턴 문자가 다르면, pi 배열을 이용해 j 위치 조정
        while j > 0 and text[i] != pattern[j]:
            j = pi[j - 1]
        # 문자가 일치하는 경우
        if text[i] == pattern[j]:
            # 패턴의 끝까지 모두 일치했다면
            if j == m - 1:
                matched_positions.append(i - m + 2) # 1-based 인덱스로 저장
                j = pi[j] # 다음 매칭을 위해 j 위치 조정
            else:
                j += 1
    return matched_positions
```

- 이 함수는 `get_pi`를 통해 얻은 `pi` 배열을 이용하여 실제 문자열 매칭을 수행합니다.
- `i`는 텍스트를 순회하는 인덱스, `j`는 패턴을 순회하는 인덱스입니다.
- `text[i]`와 `pattern[j]`가 일치하지 않으면, `get_pi`에서와 동일한 원리로 `j = pi[j-1]`을 통해 `j`의 위치를 효율적으로 이동시킵니다.
- 문자가 일치하고 패턴의 끝(`j == m-1`)까지 도달했다면, 매칭에 성공한 것입니다.
    - 매칭 시작 위치(`i - m + 2`)를 `matched_positions` 리스트에 추가합니다.
    - `j = pi[j]`를 통해 다음 매칭 가능성이 있는 위치로 `j`를 이동시킵니다.
- 문자가 일치했지만 패턴의 끝이 아니라면, `j`를 1 증가시켜 다음 문자를 비교합니다.

### 메인 로직

```python
if __name__ == "__main__":
    T = sys.stdin.readline().rstrip()
    P = sys.stdin.readline().rstrip()

    result = kmp(T, P)
    
    print(len(result))
    print(*result)
```

- 표준 입력으로 텍스트 `T`와 패턴 `P`를 한 줄씩 입력받습니다.
- `kmp` 함수를 호출하여 매칭된 위치들의 리스트를 `result`에 저장합니다.
- 문제의 요구사항에 맞게 매칭된 횟수(`len(result)`)와 매칭된 위치들을 공백으로 구분하여 출력합니다.

---

# KMP 알고리즘 함수 동작 시뮬레이션

## 1. `get_pi(pattern)` 함수 시뮬레이션

`pattern = "ababa"` 예시를 통해 `get_pi` 함수의 동작 과정을 따라가 보겠습니다.

- **초기 상태:**
  - `pattern` = "ababa" (m=5)
  - `pi` = [0, 0, 0, 0, 0]
  - `j` = 0

| i | pattern[i] | j (before) | pattern[j] | 비교 (pattern[i] == pattern[j]) | j (after) | pi | 설명 |
|---|---|---|---|---|---|---|---|
| 1 | 'b' | 0 | 'a' | `False`. `while` 조건(`j>0`)이 거짓이라 통과. | 0 | [0,0,0,0,0] | `pattern[1]`과 `pattern[0]`이 다릅니다. `j`는 0이므로 `pi[1]`은 0이 됩니다. |
| 2 | 'a' | 0 | 'a' | `True`. | 1 | [0,0,1,0,0] | `pattern[2]`와 `pattern[0]`이 같습니다. `j`를 1 증가시키고 `pi[2]`에 `j`값(1)을 저장합니다. |
| 3 | 'b' | 1 | 'b' | `True`. | 2 | [0,0,1,2,0] | `pattern[3]`과 `pattern[1]`이 같습니다. `j`를 1 증가시키고 `pi[3]`에 `j`값(2)을 저장합니다. |
| 4 | 'a' | 2 | 'a' | `True`. | 3 | [0,0,1,2,3] | `pattern[4]`와 `pattern[2]`가 같습니다. `j`를 1 증가시키고 `pi[4]`에 `j`값(3)을 저장합니다. |

- **최종 결과:** `pi` = `[0, 0, 1, 2, 3]`

---

## 2. `kmp(text, pattern)` 함수 시뮬레이션

`text = "ababcababa"`, `pattern = "ababa"` 예시를 통해 `kmp` 함수의 동작 과정을 따라가 보겠습니다.

- **초기 상태:**
  - `text` = "ababcababa" (n=10)
  - `pattern` = "ababa" (m=5)
  - `pi` = `[0, 0, 1, 2, 3]` (`get_pi` 결과)
  - `matched_positions` = []
  - `j` = 0

| i | text[i] | j (before) | pattern[j] | 비교 (text[i] == pattern[j]) | j (after) | matched_positions | 설명 |
|---|---|---|---|---|---|---|---|
| 0 | 'a' | 0 | 'a' | `True` | 1 | [] | 일치. `j` 증가. |
| 1 | 'b' | 1 | 'b' | `True` | 2 | [] | 일치. `j` 증가. |
| 2 | 'a' | 2 | 'a' | `True` | 3 | [] | 일치. `j` 증가. |
| 3 | 'b' | 3 | 'b' | `True` | 4 | [] | 일치. `j` 증가. |
| 4 | 'c' | 4 | 'a' | `False` | 0 | [] | 불일치. `j=pi[3]=2`. `text[4]`!=`pattern[2]`. 다시 불일치. `j=pi[1]=0`. `while` 종료. `text[4]`!=`pattern[0]`. 최종 `j=0`. |
| 5 | 'a' | 0 | 'a' | `True` | 1 | [] | 일치. `j` 증가. |
| 6 | 'b' | 1 | 'b' | `True` | 2 | [] | 일치. `j` 증가. |
| 7 | 'a' | 2 | 'a' | `True` | 3 | [] | 일치. `j` 증가. |
| 8 | 'b' | 3 | 'b' | `True` | 4 | [] | 일치. `j` 증가. |
| 9 | 'a' | 4 | 'a' | `True` | 3 | [6] | **매칭 성공!** `j==m-1`. `matched_positions`에 `9-5+2=6` 추가. 다음 탐색을 위해 `j=pi[4]=3`으로 변경. |

- **최종 결과:** `matched_positions` = `[6]`
